<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>VoxCall</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
  background:#0a0a0a;color:#fff;
  height:100vh;display:flex;
  align-items:center;justify-content:center;
}

#joinScreen{text-align:center;padding:24px;width:100%;max-width:360px}
#joinScreen h1{font-size:48px;margin-bottom:4px}
#joinScreen p{color:#888;font-size:14px;margin-bottom:32px}
#codeInput{
  width:100%;padding:16px;font-size:28px;font-weight:700;
  text-align:center;letter-spacing:8px;text-transform:uppercase;
  background:#1a1a1a;border:2px solid #333;border-radius:12px;
  color:#fff;outline:none;
}
#codeInput:focus{border-color:#22c55e}
#codeInput::placeholder{color:#444;letter-spacing:4px;font-weight:400;font-size:16px}
#joinBtn{
  width:100%;padding:16px;margin-top:16px;font-size:18px;font-weight:600;
  background:#22c55e;color:#fff;border:none;border-radius:12px;cursor:pointer;
}
#joinBtn:hover{background:#16a34a}
#joinBtn:active{transform:scale(.98)}
#joinBtn:disabled{background:#333;color:#666;cursor:default}
#error{color:#ef4444;font-size:13px;margin-top:12px;min-height:20px}

#callScreen{
  display:none;text-align:center;padding:24px;width:100%;height:100vh;
  flex-direction:column;align-items:center;justify-content:space-between;
  padding:60px 24px 80px;
}
#callScreen.active{display:flex}
#joinScreen.hidden{display:none}

.room-label{font-size:14px;color:#888;margin-bottom:4px}
.room-code{font-size:20px;font-weight:700;letter-spacing:4px;color:#22c55e;font-family:'Courier New',monospace}

.call-circle{
  width:140px;height:140px;border-radius:50%;background:#1a1a1a;
  border:3px solid #333;display:flex;align-items:center;justify-content:center;
  font-size:56px;margin:0 auto;transition:all .3s;
}
.call-circle.connected{border-color:#22c55e;box-shadow:0 0 40px #22c55e22}
.call-circle.waiting{animation:wp 2s infinite}
@keyframes wp{0%,100%{border-color:#333}50%{border-color:#22c55e55;box-shadow:0 0 30px #22c55e11}}

#callStatus{font-size:18px;font-weight:500;margin-top:16px}
#callTimer{font-size:14px;color:#888;margin-top:4px;font-family:'Courier New',monospace}

#volBar{width:120px;height:6px;background:#222;border-radius:3px;margin:12px auto 0;overflow:hidden}
#volFill{width:0%;height:100%;background:#22c55e;border-radius:3px;transition:width .15s}

.controls{display:flex;gap:24px;align-items:center}
.ctrl-btn{
  width:64px;height:64px;border-radius:50%;border:none;cursor:pointer;
  font-size:28px;color:#fff;display:flex;align-items:center;justify-content:center;
  transition:all .15s;
}
.ctrl-btn:active{transform:scale(.9)}
#muteBtn{background:#333}
#muteBtn.muted{background:#ef4444}
#hangBtn{background:#ef4444;width:72px;height:72px;font-size:32px}
#hangBtn:hover{background:#dc2626}
</style>
</head>
<body>

<div id="joinScreen">
  <h1>ðŸ“ž</h1>
  <p>Enter a room code. Same code = instant call.</p>
  <input type="text" id="codeInput" placeholder="ROOM CODE" maxlength="8" autocomplete="off">
  <button id="joinBtn">Join Room</button>
  <div id="error"></div>
</div>

<div id="callScreen">
  <div>
    <div class="room-label">ROOM</div>
    <div class="room-code" id="showCode">------</div>
  </div>
  <div>
    <div class="call-circle waiting" id="callCircle">ðŸ“ž</div>
    <div id="callStatus">Waiting for other person...</div>
    <div id="callTimer"></div>
    <div id="volBar"><div id="volFill"></div></div>
  </div>
  <div class="controls">
    <button class="ctrl-btn" id="muteBtn">ðŸŽ¤</button>
    <button class="ctrl-btn" id="hangBtn">ðŸ“µ</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
(function(){

let socket = null;
let sendCtx = null;       // separate context for capturing mic
let recvCtx = null;       // separate context for playback
let micStream = null;
let micSource = null;
let processor = null;
let muted = false;
let callStart = null;
let timerInterval = null;
let currentRoom = null;
let connected = false;

// â”€â”€ NOISE SUPPRESSION CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const NOISE_GATE_THRESHOLD = 400;     // Int16 value. Below this = silence
const SMOOTHING_SAMPLES = 64;         // Crossfade between chunks to prevent clicks
const PLAYBACK_GAIN = 1.0;            // No amplification (was 1.5 = noise)
let nextPlayTime = 0;                 // Schedule playback to avoid gaps/overlaps

const $ = id => document.getElementById(id);

// â”€â”€ JOIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$("joinBtn").onclick = join;
$("codeInput").onkeydown = e => { if(e.key==="Enter") join(); };
$("codeInput").oninput = () => {
  $("codeInput").value = $("codeInput").value.toUpperCase().replace(/[^A-Z0-9]/g,"");
};

function join(){
  const code = $("codeInput").value.trim();
  if(!code || code.length < 3){
    $("error").textContent = "Enter at least 3 characters";
    return;
  }

  $("joinBtn").disabled = true;
  $("joinBtn").textContent = "Getting mic...";
  $("error").textContent = "";

  navigator.mediaDevices.getUserMedia({
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
    },
    video: false,
  }).then(stream => {
    micStream = stream;
    $("joinBtn").textContent = "Joining...";
    connectAndJoin(code);
  }).catch(e => {
    $("joinBtn").disabled = false;
    $("joinBtn").textContent = "Join Room";
    $("error").textContent = "Mic access denied. Allow microphone and try again.";
  });
}

function connectAndJoin(code){
  socket = io({
    transports: ["websocket", "polling"],
    reconnection: true,
    reconnectionDelay: 1000,
  });

  socket.on("connect", () => {
    socket.emit("join", code, res => {
      if(!res.ok){
        $("joinBtn").disabled = false;
        $("joinBtn").textContent = "Join Room";
        $("error").textContent = res.error;
        cleanup();
        return;
      }
      currentRoom = code;
      showCallScreen(code);
      if(res.count === 2) startAudio();
    });
  });

  socket.on("room-count", n => {
    if(n >= 2 && !connected) startAudio();
    if(n < 2){
      connected = false;
      $("callStatus").textContent = "Waiting for other person...";
      $("callCircle").className = "call-circle waiting";
      $("callCircle").textContent = "ðŸ“ž";
      $("callTimer").textContent = "";
      $("volFill").style.width = "0%";
      stopTimer();
    }
  });

  socket.on("audio", (data) => { playAudio(data); });

  socket.on("peer-left", () => {
    connected = false;
    $("callStatus").textContent = "Other person left. Waiting...";
    $("callCircle").className = "call-circle waiting";
    $("callCircle").textContent = "ðŸ“ž";
    $("callTimer").textContent = "";
    $("volFill").style.width = "0%";
    stopTimer();
    nextPlayTime = 0;
  });

  socket.on("disconnect", () => {
    $("callStatus").textContent = "Reconnecting...";
  });

  socket.on("reconnect", () => {
    if(currentRoom){
      socket.emit("join", currentRoom, res => {
        if(res.ok && res.count >= 2) startAudio();
      });
    }
  });
}

function showCallScreen(code){
  $("joinScreen").classList.add("hidden");
  $("callScreen").classList.add("active");
  $("showCode").textContent = code;
}

// â”€â”€ NOISE SUPPRESSION: SENDING SIDE â”€â”€â”€â”€â”€â”€
// Removes low-level noise before sending

function noiseGate(int16arr){
  // Calculate RMS energy of the frame
  let sum = 0;
  for(let i = 0; i < int16arr.length; i++){
    sum += int16arr[i] * int16arr[i];
  }
  const rms = Math.sqrt(sum / int16arr.length);

  // If below threshold, zero it out (silence)
  if(rms < NOISE_GATE_THRESHOLD){
    return null; // don't send silence at all
  }

  // Soft noise gate: reduce quiet parts further
  // Anything below half the threshold gets attenuated
  const halfThresh = NOISE_GATE_THRESHOLD / 2;
  const result = new Int16Array(int16arr.length);
  for(let i = 0; i < int16arr.length; i++){
    const absVal = Math.abs(int16arr[i]);
    if(absVal < halfThresh){
      // Attenuate noise floor
      result[i] = Math.round(int16arr[i] * 0.1);
    } else {
      result[i] = int16arr[i];
    }
  }

  return result;
}

// Simple high-pass filter to remove low frequency rumble
function highPassFilter(int16arr){
  const result = new Int16Array(int16arr.length);
  let prev = 0;
  const alpha = 0.95; // Higher = more bass cut

  for(let i = 0; i < int16arr.length; i++){
    const curr = int16arr[i];
    result[i] = Math.round(alpha * (prev + curr - (i > 0 ? int16arr[i-1] : 0)));
    prev = result[i];
  }

  return result;
}

// â”€â”€ AUDIO CAPTURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startAudio(){
  if(connected) return;
  connected = true;

  $("callStatus").textContent = "Connected";
  $("callCircle").className = "call-circle connected";
  $("callCircle").textContent = "ðŸ”Š";
  startTimer();

  // SEPARATE contexts for send and receive to prevent echo
  if(!sendCtx){
    sendCtx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 16000,
    });
  }
  if(sendCtx.state === "suspended") sendCtx.resume();

  if(!recvCtx){
    recvCtx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 16000,
    });
  }
  if(recvCtx.state === "suspended") recvCtx.resume();

  nextPlayTime = 0;

  // Mic â†’ processor (capture only, NOT connected to output)
  micSource = sendCtx.createMediaStreamSource(micStream);
  processor = sendCtx.createScriptProcessor(4096, 1, 1);

  // Dummy destination so processor actually processes
  // But we DON'T play mic audio locally (prevents echo)
  const silentGain = sendCtx.createGain();
  silentGain.gain.value = 0;  // MUTE local playback of mic

  processor.onaudioprocess = (e) => {
    if(muted || !connected || !socket) return;

    const input = e.inputBuffer.getChannelData(0);

    // Float32 â†’ Int16
    let buf = new Int16Array(input.length);
    for(let i = 0; i < input.length; i++){
      let s = Math.max(-1, Math.min(1, input[i]));
      buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }

    // Apply high-pass filter (removes rumble/hum)
    buf = highPassFilter(buf);

    // Apply noise gate
    const gated = noiseGate(buf);
    if(!gated){
      // Silence â€” update UI but don't send
      $("volFill").style.width = "0%";
      return;
    }

    // Update volume bar
    let maxVal = 0;
    for(let i = 0; i < gated.length; i++){
      const v = Math.abs(gated[i]);
      if(v > maxVal) maxVal = v;
    }
    const vol = Math.min(100, (maxVal / 5000) * 100);
    $("volFill").style.width = vol + "%";

    // Send compressed audio
    socket.volatile.emit("audio", gated.buffer);
  };

  micSource.connect(processor);
  processor.connect(silentGain);
  silentGain.connect(sendCtx.destination);
}

// â”€â”€ AUDIO PLAYBACK (with smoothing) â”€â”€â”€â”€â”€â”€
function playAudio(arrayBuf){
  if(!recvCtx){
    recvCtx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 16000,
    });
  }
  if(recvCtx.state === "suspended") recvCtx.resume();

  try{
    // Int16 â†’ Float32
    const int16 = new Int16Array(arrayBuf);
    const float32 = new Float32Array(int16.length);
    for(let i = 0; i < int16.length; i++){
      float32[i] = int16[i] / (int16[i] < 0 ? 0x8000 : 0x7FFF);
    }

    // â”€â”€ Apply receive-side noise reduction â”€â”€
    // Soft limiter to prevent harsh peaks
    for(let i = 0; i < float32.length; i++){
      const x = float32[i];
      // Soft clipping using tanh-like curve
      if(Math.abs(x) > 0.5){
        float32[i] = x > 0
          ? 0.5 + 0.5 * Math.tanh(2 * (x - 0.5))
          : -0.5 - 0.5 * Math.tanh(2 * (-x - 0.5));
      }
    }

    // â”€â”€ Fade in/out edges to prevent clicks â”€â”€
    const fadeLen = Math.min(SMOOTHING_SAMPLES, float32.length / 4);
    for(let i = 0; i < fadeLen; i++){
      const t = i / fadeLen;
      // Smooth fade curve (sine)
      const fade = 0.5 * (1 - Math.cos(Math.PI * t));
      float32[i] *= fade;
      float32[float32.length - 1 - i] *= fade;
    }

    // Create buffer
    const audioBuf = recvCtx.createBuffer(1, float32.length, 16000);
    audioBuf.getChannelData(0).set(float32);

    const source = recvCtx.createBufferSource();
    source.buffer = audioBuf;

    // â”€â”€ Playback chain: source â†’ lowpass â†’ gain â†’ output â”€â”€

    // Low-pass filter: cuts harsh high frequency noise
    const lowpass = recvCtx.createBiquadFilter();
    lowpass.type = "lowpass";
    lowpass.frequency.value = 7000;  // Voice is mostly below 4kHz, keep some headroom
    lowpass.Q.value = 0.7;

    // High-pass filter: cuts rumble
    const highpass = recvCtx.createBiquadFilter();
    highpass.type = "highpass";
    highpass.frequency.value = 80;   // Cut below 80Hz
    highpass.Q.value = 0.7;

    // Compressor: normalizes loud/quiet parts
    const compressor = recvCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;
    compressor.knee.value = 12;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.1;

    // Final gain (no amplification!)
    const gain = recvCtx.createGain();
    gain.gain.value = PLAYBACK_GAIN;

    // Connect chain
    source.connect(highpass);
    highpass.connect(lowpass);
    lowpass.connect(compressor);
    compressor.connect(gain);
    gain.connect(recvCtx.destination);

    // â”€â”€ Schedule playback seamlessly â”€â”€
    const now = recvCtx.currentTime;
    const duration = audioBuf.duration;

    if(nextPlayTime < now){
      // We're behind â€” play immediately with tiny offset
      nextPlayTime = now + 0.01;
    }

    source.start(nextPlayTime);
    nextPlayTime += duration;

    // Update volume bar
    let maxVal = 0;
    for(let i = 0; i < float32.length; i++){
      const v = Math.abs(float32[i]);
      if(v > maxVal) maxVal = v;
    }
    $("volFill").style.width = Math.min(100, maxVal * 120) + "%";

  }catch(e){
    // Ignore playback errors
  }
}

// â”€â”€ TIMER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startTimer(){
  callStart = Date.now();
  stopTimer();
  timerInterval = setInterval(() => {
    const s = Math.floor((Date.now() - callStart) / 1000);
    const m = Math.floor(s/60).toString().padStart(2,"0");
    const sec = (s%60).toString().padStart(2,"0");
    $("callTimer").textContent = `${m}:${sec}`;
  }, 1000);
}
function stopTimer(){
  if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
}

// â”€â”€ CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$("muteBtn").onclick = () => {
  muted = !muted;
  $("muteBtn").textContent = muted ? "ðŸ”‡" : "ðŸŽ¤";
  $("muteBtn").classList.toggle("muted", muted);
  if(muted) $("volFill").style.width = "0%";
};

$("hangBtn").onclick = () => {
  cleanup();
  $("callScreen").classList.remove("active");
  $("joinScreen").classList.remove("hidden");
  $("joinBtn").disabled = false;
  $("joinBtn").textContent = "Join Room";
  $("callTimer").textContent = "";
  $("codeInput").value = "";
  $("volFill").style.width = "0%";
};

function cleanup(){
  connected = false;
  stopTimer();
  nextPlayTime = 0;
  if(processor){ try{processor.disconnect()}catch(e){} processor=null; }
  if(micSource){ try{micSource.disconnect()}catch(e){} micSource=null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
  if(sendCtx){ try{sendCtx.close()}catch(e){} sendCtx=null; }
  if(recvCtx){ try{recvCtx.close()}catch(e){} recvCtx=null; }
  if(socket){ socket.disconnect(); socket=null; }
  currentRoom = null;
}

// â”€â”€ KEEP SCREEN ON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let wakeLock = null;
async function keepAwake(){
  if(!("wakeLock" in navigator)) return;
  try{ wakeLock = await navigator.wakeLock.request("screen"); }catch(e){}
}
keepAwake();
document.addEventListener("visibilitychange", () => { if(!document.hidden) keepAwake(); });
window.addEventListener("beforeunload", cleanup);

$("codeInput").focus();
console.log("ðŸ“ž VoxCall ready (clean audio mode)");

})();
</script>
</body>
</html>
